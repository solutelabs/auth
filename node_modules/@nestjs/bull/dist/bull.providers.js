"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createQueueProviders = exports.createQueueOptionProviders = void 0;
const common_1 = require("@nestjs/common");
const Bull = require("bull");
const helpers_1 = require("./helpers");
const utils_1 = require("./utils");
const helpers_2 = require("./utils/helpers");
function buildQueue(options) {
    const queueName = options.name ? options.name : 'default';
    const queue = typeof (options === null || options === void 0 ? void 0 : options.redis) === 'string'
        ? new Bull(queueName, options.redis, options)
        : new Bull(queueName, options);
    if (options.processors) {
        options.processors.forEach((processor) => {
            let args = [];
            if ((0, helpers_2.isAdvancedProcessor)(processor)) {
                args.push(processor.name, processor.concurrency, processor.callback);
            }
            else if ((0, helpers_2.isAdvancedSeparateProcessor)(processor)) {
                args.push(processor.name, processor.concurrency, processor.path);
            }
            else if ((0, helpers_2.isSeparateProcessor)(processor)) {
                args.push(processor);
            }
            else if ((0, helpers_2.isProcessorCallback)(processor)) {
                args.push(processor);
            }
            args = args.filter((arg) => typeof arg !== 'undefined');
            queue.process.call(queue, ...args);
        });
    }
    queue.onApplicationShutdown = function () {
        return this.close();
    };
    return queue;
}
function createQueueOptionProviders(options) {
    const providers = options.map((option) => {
        const optionalSharedConfigHolder = (0, helpers_1.createConditionalDepHolder)((0, utils_1.getSharedConfigToken)(option.configKey));
        return [
            optionalSharedConfigHolder,
            {
                provide: (0, utils_1.getQueueOptionsToken)(option.name),
                useFactory: (optionalDepHolder) => {
                    return Object.assign(Object.assign({}, optionalDepHolder.getDependencyRef(option.name)), option);
                },
                inject: [optionalSharedConfigHolder],
            },
        ];
    });
    return (0, common_1.flatten)(providers);
}
exports.createQueueOptionProviders = createQueueOptionProviders;
function createQueueProviders(options) {
    return options.map((option) => ({
        provide: (0, utils_1.getQueueToken)(option.name),
        useFactory: (o) => {
            const queueName = o.name || option.name;
            return buildQueue(Object.assign(Object.assign({}, o), { name: queueName }));
        },
        inject: [(0, utils_1.getQueueOptionsToken)(option.name)],
    }));
}
exports.createQueueProviders = createQueueProviders;
